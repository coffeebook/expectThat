/**
 * Pavlov - Test framework-independent behavioral API
 *
 * version 0.3.0pre
 *
 * http://github.com/mmonteleone/pavlov
 *
 * Copyright (c) 2009-2011 Michael Monteleone
 * Licensed under terms of the MIT License (README.markdown)
 */(function(a){function f(a){if(a){this.parent=a;this.parent.children.push(this)}else c.push(this);this.children=[];this.specs=[]}function g(a){this.value=a}var b={each:function(a,b){if(typeof a=="undefined"||typeof b=="undefined"||a===null||b===null)throw"both 'target' and 'callback' arguments are required";var c,d=0,e=a.length,f;if(e===undefined){for(c in a)if(a.hasOwnProperty(c)&&b.call(a[c],c,a[c])===!1)break}else for(f=a[0];d<e&&b.call(f,d,f)!==!1;f=a[++d]);return a},makeArray:function(a){return Array.prototype.slice.call(a)},isArray:function(a){return Object.prototype.toString.call(a)==="[object Array]"},extend:function(a,b){if(typeof a=="undefined"||typeof b=="undefined"||a===null||b===null)throw"both 'source' and 'target' arguments are required";var c;for(c in b)b.hasOwnProperty(c)&&(a[c]=b[c])},serialize:function(a){return typeof a=="undefined"?"":Object.prototype.toString.call(a)==="[object Array]"?"["+a.toString()+"]":Object.prototype.toString.call(a)==="[object Function]"?"function()":typeof a=="string"?'"'+a+'"':a},phraseCase:function(a){return a.replace(/([A-Z])/g," $1").toLowerCase()}},c=[],d,e=function(a,b){var c=[];while(a!==null){c.push(a[b]);a=a.parent}return c};b.extend(f.prototype,{name:"",parent:null,children:[],specs:[],before:function(){},after:function(){},befores:function(){return e(this,"before").reverse()},afters:function(){return e(this,"after")},names:function(){return e(this,"name").reverse().join(", ")}});var h=function(a){b.each(a,function(a,c){g.prototype[a]=function(){var d=b.makeArray(arguments);d.unshift(this.value);if(c.length===2)d[1]=d[1]||"asserting "+b.serialize(d[0])+" "+b.phraseCase(a);else if(c.length===3){var e=b.serialize(d[1]);d[2]=d[2]||"asserting "+b.serialize(d[0])+" "+b.phraseCase(a)+(e?" "+e:e)}c.apply(this,d)}})};h({equals:function(a,b,c){l.assert(a==b,c)},isEqualTo:function(a,b,c){l.assert(a==b,c)},isNotEqualTo:function(a,b,c){l.assert(a!=b,c)},isStrictlyEqualTo:function(a,b,c){l.assert(a===b,c)},isNotStrictlyEqualTo:function(a,b,c){l.assert(a!==b,c)},isTrue:function(a,b){l.assert(a,b)},isFalse:function(a,b){l.assert(!a,b)},isNull:function(a,b){l.assert(a===null,b)},isNotNull:function(a,b){l.assert(a!==null,b)},isDefined:function(a,b){l.assert(typeof a!="undefined",b)},isUndefined:function(a,b){l.assert(typeof a=="undefined",b)},pass:function(a,b){l.assert(!0,b)},fail:function(a,b){l.assert(!1,b)},throwsException:function(a,b,c){try{a();l.assert(!1,c)}catch(d){l.assert(d===(b||d),c)}}});var i={describe:function(a,b){if(arguments.length<2)throw"both 'description' and 'fn' arguments are required";var c=d;try{d=new f(d);d.name=a;b()}finally{d=c}},before:function(a){if(arguments.length===0)throw"'fn' argument is required";d.before=a},after:function(a){if(arguments.length===0)throw"'fn' argument is required";d.after=a},it:function(a,b){if(arguments.length===0)throw"'specification' argument is required";if(b){b.async&&(a+=" asynchronously");d.specs.push([a,b])}else i.it(a,function(){i.assert.fail("Not Implemented")})},async:function(a){var b=function(){l.pause();a.apply(this,arguments)};b.async=!0;return b},given:function(){if(arguments.length===0)throw"at least one argument is required";var a=b.makeArray(arguments);arguments.length===1&&b.isArray(arguments[0])&&(a=a[0]);return{it:function(c,d){b.each(a,function(){var a=this;i.it("given "+a+", "+c,function(){d.apply(this,b.isArray(a)?a:[a])})})}}},assert:function(a){return new g(a)},wait:function(b,c){if(arguments.length<2)throw"both 'ms' and 'fn' arguments are required";l.pause();a.setTimeout(function(){c();l.resume()},b)},pause:function(){l.pause()},resume:function(){l.resume()}};b.each(["pass","fail"],function(a,b){i.assert[b]=function(a){i.assert()[b](a)}});var j=function(a,c,d){var e=a.toString().match(/\(([^\)]*)\)/)[1],f=a.toString().match(/^[^\{]*\{((.*\s*)*)\}/m)[1];a=new Function("extraScope"+(e?", "+e:""),"with(extraScope){"+f+"}");return function(){var e=[d];b.each(arguments,function(){e.push(this)});a.apply(c,e)}},k=function(e,f){if(arguments.length<2)throw"both 'name' and 'fn' arguments are required";c=[];d=null;e+=" Specifications";typeof document!="undefined"&&(document.title=e+" - Pavlov - "+l.name);l.initiate(e);if(k.globalApi){b.extend(a,i);f()}else j(f,this,i)();l.compile(e,c)()},l={initiate:function(a){},assert:function(a,b){throw"'assert' must be implemented by a test framework adapter"},compile:function(a,b){throw"'compile' must be implemented by a test framework adapter"},pause:function(){throw"'pause' not implemented by current test framework adapter"},resume:function(){throw"'resume' not implemented by current test framework adapter"}};a.pavlov={version:"0.3.0pre",specify:k,adapter:l,adapt:function(a,c){if(typeof a=="undefined"||typeof c=="undefined"||a===null||c===null)throw"both 'frameworkName' and 'testFrameworkAdapter' arguments are required";l.name=a;b.extend(l,c)},util:{each:b.each,extend:b.extend},api:i,globalApi:!1,extendAssertions:h}})(window);(function(){if(typeof QUnit=="undefined")return;pavlov.adapt("QUnit",{initiate:function(a){var b=function(a,b,c){a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent&&a.attachEvent("on"+b,c)};b(window,"load",function(){var b=document.getElementsByTagName("h1");b.length>0&&(b[0].innerHTML=a)})},assert:function(a,b){ok(a,b)},pause:function(){stop()},resume:function(){start()},compile:function(a,b){var c=[],d=pavlov.util.each,e=function(a){var b=a.befores(),f=a.afters();c.push(function(){module(a.names(),{setup:function(){d(b,function(){this()})},teardown:function(){d(f,function(){this()})}})});d(a.specs,function(){var a=this;c.push(function(){test(a[0],a[1])})});d(a.children,function(){e(this)})};d(b,function(){e(this,c)});return function(){d(c,function(){this()})}}});pavlov.extendAssertions({isSameAs:function(a,b,c){deepEqual(a,b,c)},isNotSameAs:function(a,b,c){notDeepEqual(a,b,c)}});QUnit.specify=pavlov.specify;pavlov.util.extend(QUnit.specify,pavlov)})();